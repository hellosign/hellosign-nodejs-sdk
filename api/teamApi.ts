/**
 * HelloSign API
 * HelloSign v3 API
 *
 * The version of the OpenAPI document: 3.0.0
 * Contact: apisupport@hellosign.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import axios, { AxiosError, AxiosRequestConfig } from "axios";

/* tslint:disable:no-unused-locals */
import { ErrorResponse } from "../model/errorResponse";
import { TeamAddMemberRequest } from "../model/teamAddMemberRequest";
import { TeamCreateRequest } from "../model/teamCreateRequest";
import { TeamGetInfoResponse } from "../model/teamGetInfoResponse";
import { TeamGetResponse } from "../model/teamGetResponse";
import { TeamMembersResponse } from "../model/teamMembersResponse";
import { TeamRemoveMemberRequest } from "../model/teamRemoveMemberRequest";
import { TeamSubTeamsResponse } from "../model/teamSubTeamsResponse";
import { TeamUpdateRequest } from "../model/teamUpdateRequest";

import {
  ObjectSerializer,
  Authentication,
  VoidAuth,
  Interceptor,
} from "../model/models";
import {
  HttpBasicAuth,
  HttpBearerAuth,
  ApiKeyAuth,
  OAuth,
} from "../model/models";

import {
  HttpError,
  optionsI,
  returnTypeT,
  returnTypeI,
  generateFormData,
  toFormData,
  queryParamsSerializer,
} from "./apis";

let defaultBasePath = "https://api.hellosign.com/v3";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum TeamApiApiKeys {}

export class TeamApi {
  protected _basePath = defaultBasePath;
  protected _defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  /**
   * Allows instantiating files when using ObjectSerializer::deserialize()
   * @param bool
   */
  protected _instantiateFiles = false;

  /**
   * Define the base location to look for file uploads
   * @param path
   */
  protected _rootFilePath?: string;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    api_key: new HttpBasicAuth(),
    oauth2: new HttpBearerAuth(),
  };

  protected interceptors: Interceptor[] = [];

  constructor(basePath?: string) {
    if (basePath) {
      this.basePath = basePath;
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  set defaultHeaders(defaultHeaders: any) {
    this._defaultHeaders = defaultHeaders;
  }

  get defaultHeaders() {
    return this._defaultHeaders;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: string) {
    this.authentications.api_key.username = key;
  }

  set username(username: string) {
    this.authentications.api_key.username = username;
  }

  set password(password: string) {
    this.authentications.api_key.password = password;
  }

  set accessToken(accessToken: string | (() => string)) {
    this.authentications.oauth2.accessToken = accessToken;
  }

  public addInterceptor(interceptor: Interceptor) {
    this.interceptors.push(interceptor);
  }

  set instantiateFiles(flag: boolean) {
    this._instantiateFiles = flag;
  }

  set rootFilePath(path: string | undefined) {
    this._rootFilePath = path;
  }

  /**
   * Invites a user (specified using the `email_address` parameter) to your Team. If the user does not currently have a HelloSign Account, a new one will be created for them. If a user is already a part of another Team, a `team_invite_failed` error will be returned.
   * @summary Add User to Team
   * @param teamAddMemberRequest
   * @param teamId The id of the team.
   * @param options
   */
  public async teamAddMember(
    teamAddMemberRequest: TeamAddMemberRequest,
    teamId?: string,
    options: optionsI = { headers: {} }
  ): Promise<returnTypeT<TeamGetResponse>> {
    const localVarPath = this.basePath + "/team/add_member";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams["content-type"] = "application/json";
    } else {
      localVarHeaderParams["content-type"] = produces.join(",");
    }
    let localVarFormParams: any = {};
    let localVarBodyParams: any = undefined;

    // verify required parameter 'teamAddMemberRequest' is not null or undefined
    if (teamAddMemberRequest === null || teamAddMemberRequest === undefined) {
      throw new Error(
        "Required parameter teamAddMemberRequest was null or undefined when calling teamAddMember."
      );
    }

    if (teamId !== undefined) {
      localVarQueryParameters["team_id"] = ObjectSerializer.serialize(
        teamId,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    const result = generateFormData(
      teamAddMemberRequest,
      TeamAddMemberRequest.attributeTypeMap,
      this._instantiateFiles,
      this._rootFilePath
    );
    localVarUseFormData = result.localVarUseFormData;

    let data = {};
    if (localVarUseFormData) {
      const formData = toFormData(result.data);
      data = formData;
      localVarHeaderParams = {
        ...localVarHeaderParams,
        ...formData.getHeaders(),
      };
    } else {
      data = ObjectSerializer.serialize(
        teamAddMemberRequest,
        "TeamAddMemberRequest"
      );
    }

    let localVarRequestOptions: AxiosRequestConfig = {
      method: "PUT",
      params: localVarQueryParameters,
      headers: localVarHeaderParams,
      url: localVarPath,
      paramsSerializer: this._useQuerystring
        ? queryParamsSerializer
        : undefined,
      responseType: "json",
      data,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.api_key.username) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.api_key.applyToRequest(localVarRequestOptions)
      );
    }
    if (this.authentications.oauth2.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.oauth2.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      return new Promise<returnTypeT<TeamGetResponse>>((resolve, reject) => {
        axios.request(localVarRequestOptions).then(
          (response) => {
            let body = response.data;

            if (
              response.status &&
              response.status >= 200 &&
              response.status <= 299
            ) {
              body = ObjectSerializer.deserialize(body, "TeamGetResponse");
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.status));
            }
          },
          (error: AxiosError) => {
            if (error.response == null) {
              reject(error);
              return;
            }

            const response = error.response;

            let body;

            if (response.status === 200) {
              body = ObjectSerializer.deserialize(
                response.data,
                "TeamGetResponse"
              );

              reject(new HttpError(response, body, response.status));
              return;
            }

            let rangeCodeLeft = Number("4XX"[0] + "00");
            let rangeCodeRight = Number("4XX"[0] + "99");
            if (
              response.status >= rangeCodeLeft &&
              response.status <= rangeCodeRight
            ) {
              body = ObjectSerializer.deserialize(
                response.data,
                "ErrorResponse"
              );

              reject(new HttpError(response, body, response.status));
              return;
            }
          }
        );
      });
    });
  }
  /**
   * Creates a new Team and makes you a member. You must not currently belong to a Team to invoke.
   * @summary Create Team
   * @param teamCreateRequest
   * @param options
   */
  public async teamCreate(
    teamCreateRequest: TeamCreateRequest,
    options: optionsI = { headers: {} }
  ): Promise<returnTypeT<TeamGetResponse>> {
    const localVarPath = this.basePath + "/team/create";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams["content-type"] = "application/json";
    } else {
      localVarHeaderParams["content-type"] = produces.join(",");
    }
    let localVarFormParams: any = {};
    let localVarBodyParams: any = undefined;

    // verify required parameter 'teamCreateRequest' is not null or undefined
    if (teamCreateRequest === null || teamCreateRequest === undefined) {
      throw new Error(
        "Required parameter teamCreateRequest was null or undefined when calling teamCreate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    const result = generateFormData(
      teamCreateRequest,
      TeamCreateRequest.attributeTypeMap,
      this._instantiateFiles,
      this._rootFilePath
    );
    localVarUseFormData = result.localVarUseFormData;

    let data = {};
    if (localVarUseFormData) {
      const formData = toFormData(result.data);
      data = formData;
      localVarHeaderParams = {
        ...localVarHeaderParams,
        ...formData.getHeaders(),
      };
    } else {
      data = ObjectSerializer.serialize(teamCreateRequest, "TeamCreateRequest");
    }

    let localVarRequestOptions: AxiosRequestConfig = {
      method: "POST",
      params: localVarQueryParameters,
      headers: localVarHeaderParams,
      url: localVarPath,
      paramsSerializer: this._useQuerystring
        ? queryParamsSerializer
        : undefined,
      responseType: "json",
      data,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.api_key.username) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.api_key.applyToRequest(localVarRequestOptions)
      );
    }
    if (this.authentications.oauth2.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.oauth2.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      return new Promise<returnTypeT<TeamGetResponse>>((resolve, reject) => {
        axios.request(localVarRequestOptions).then(
          (response) => {
            let body = response.data;

            if (
              response.status &&
              response.status >= 200 &&
              response.status <= 299
            ) {
              body = ObjectSerializer.deserialize(body, "TeamGetResponse");
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.status));
            }
          },
          (error: AxiosError) => {
            if (error.response == null) {
              reject(error);
              return;
            }

            const response = error.response;

            let body;

            if (response.status === 200) {
              body = ObjectSerializer.deserialize(
                response.data,
                "TeamGetResponse"
              );

              reject(new HttpError(response, body, response.status));
              return;
            }

            let rangeCodeLeft = Number("4XX"[0] + "00");
            let rangeCodeRight = Number("4XX"[0] + "99");
            if (
              response.status >= rangeCodeLeft &&
              response.status <= rangeCodeRight
            ) {
              body = ObjectSerializer.deserialize(
                response.data,
                "ErrorResponse"
              );

              reject(new HttpError(response, body, response.status));
              return;
            }
          }
        );
      });
    });
  }
  /**
   * Deletes your Team. Can only be invoked when you have a Team with only one member (yourself).
   * @summary Delete Team
   * @param options
   */
  public async teamDelete(
    options: optionsI = { headers: {} }
  ): Promise<returnTypeI> {
    const localVarPath = this.basePath + "/team/destroy";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams["content-type"] = "application/json";
    } else {
      localVarHeaderParams["content-type"] = produces.join(",");
    }
    let localVarFormParams: any = {};
    let localVarBodyParams: any = undefined;

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: AxiosRequestConfig = {
      method: "DELETE",
      params: localVarQueryParameters,
      headers: localVarHeaderParams,
      url: localVarPath,
      paramsSerializer: this._useQuerystring
        ? queryParamsSerializer
        : undefined,
      responseType: "json",
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.api_key.username) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.api_key.applyToRequest(localVarRequestOptions)
      );
    }
    if (this.authentications.oauth2.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.oauth2.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      return new Promise<returnTypeI>((resolve, reject) => {
        axios.request(localVarRequestOptions).then(
          (response) => {
            let body = response.data;

            if (
              response.status &&
              response.status >= 200 &&
              response.status <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.status));
            }
          },
          (error: AxiosError) => {
            if (error.response == null) {
              reject(error);
              return;
            }

            const response = error.response;

            let body;
          }
        );
      });
    });
  }
  /**
   * Returns information about your Team as well as a list of its members. If you do not belong to a Team, a 404 error with an error_name of \"not_found\" will be returned.
   * @summary Get Team
   * @param options
   */
  public async teamGet(
    options: optionsI = { headers: {} }
  ): Promise<returnTypeT<TeamGetResponse>> {
    const localVarPath = this.basePath + "/team";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams["content-type"] = "application/json";
    } else {
      localVarHeaderParams["content-type"] = produces.join(",");
    }
    let localVarFormParams: any = {};
    let localVarBodyParams: any = undefined;

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: AxiosRequestConfig = {
      method: "GET",
      params: localVarQueryParameters,
      headers: localVarHeaderParams,
      url: localVarPath,
      paramsSerializer: this._useQuerystring
        ? queryParamsSerializer
        : undefined,
      responseType: "json",
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.api_key.username) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.api_key.applyToRequest(localVarRequestOptions)
      );
    }
    if (this.authentications.oauth2.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.oauth2.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      return new Promise<returnTypeT<TeamGetResponse>>((resolve, reject) => {
        axios.request(localVarRequestOptions).then(
          (response) => {
            let body = response.data;

            if (
              response.status &&
              response.status >= 200 &&
              response.status <= 299
            ) {
              body = ObjectSerializer.deserialize(body, "TeamGetResponse");
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.status));
            }
          },
          (error: AxiosError) => {
            if (error.response == null) {
              reject(error);
              return;
            }

            const response = error.response;

            let body;

            if (response.status === 200) {
              body = ObjectSerializer.deserialize(
                response.data,
                "TeamGetResponse"
              );

              reject(new HttpError(response, body, response.status));
              return;
            }

            let rangeCodeLeft = Number("4XX"[0] + "00");
            let rangeCodeRight = Number("4XX"[0] + "99");
            if (
              response.status >= rangeCodeLeft &&
              response.status <= rangeCodeRight
            ) {
              body = ObjectSerializer.deserialize(
                response.data,
                "ErrorResponse"
              );

              reject(new HttpError(response, body, response.status));
              return;
            }
          }
        );
      });
    });
  }
  /**
   * Provides information about a team.
   * @summary Get Team Info
   * @param teamId The id of the team.
   * @param options
   */
  public async teamInfo(
    teamId?: string,
    options: optionsI = { headers: {} }
  ): Promise<returnTypeT<TeamGetInfoResponse>> {
    const localVarPath = this.basePath + "/team/info";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams["content-type"] = "application/json";
    } else {
      localVarHeaderParams["content-type"] = produces.join(",");
    }
    let localVarFormParams: any = {};
    let localVarBodyParams: any = undefined;

    if (teamId !== undefined) {
      localVarQueryParameters["team_id"] = ObjectSerializer.serialize(
        teamId,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: AxiosRequestConfig = {
      method: "GET",
      params: localVarQueryParameters,
      headers: localVarHeaderParams,
      url: localVarPath,
      paramsSerializer: this._useQuerystring
        ? queryParamsSerializer
        : undefined,
      responseType: "json",
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.api_key.username) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.api_key.applyToRequest(localVarRequestOptions)
      );
    }
    if (this.authentications.oauth2.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.oauth2.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      return new Promise<returnTypeT<TeamGetInfoResponse>>(
        (resolve, reject) => {
          axios.request(localVarRequestOptions).then(
            (response) => {
              let body = response.data;

              if (
                response.status &&
                response.status >= 200 &&
                response.status <= 299
              ) {
                body = ObjectSerializer.deserialize(
                  body,
                  "TeamGetInfoResponse"
                );
                resolve({ response: response, body: body });
              } else {
                reject(new HttpError(response, body, response.status));
              }
            },
            (error: AxiosError) => {
              if (error.response == null) {
                reject(error);
                return;
              }

              const response = error.response;

              let body;

              if (response.status === 200) {
                body = ObjectSerializer.deserialize(
                  response.data,
                  "TeamGetInfoResponse"
                );

                reject(new HttpError(response, body, response.status));
                return;
              }

              let rangeCodeLeft = Number("4XX"[0] + "00");
              let rangeCodeRight = Number("4XX"[0] + "99");
              if (
                response.status >= rangeCodeLeft &&
                response.status <= rangeCodeRight
              ) {
                body = ObjectSerializer.deserialize(
                  response.data,
                  "ErrorResponse"
                );

                reject(new HttpError(response, body, response.status));
                return;
              }
            }
          );
        }
      );
    });
  }
  /**
   * Provides a paginated list of members (and their roles) that belong to a given team.
   * @summary List Team Members
   * @param teamId The id of the team that a member list is being requested from.
   * @param page Which page number of the team member list to return. Defaults to &#x60;1&#x60;.
   * @param pageSize Number of objects to be returned per page. Must be between &#x60;1&#x60; and &#x60;100&#x60;. Default is &#x60;20&#x60;.
   * @param options
   */
  public async teamMembers(
    teamId: string,
    page?: number,
    pageSize?: number,
    options: optionsI = { headers: {} }
  ): Promise<returnTypeT<TeamMembersResponse>> {
    const localVarPath =
      this.basePath +
      "/team/members/{team_id}".replace(
        "{" + "team_id" + "}",
        encodeURIComponent(String(teamId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams["content-type"] = "application/json";
    } else {
      localVarHeaderParams["content-type"] = produces.join(",");
    }
    let localVarFormParams: any = {};
    let localVarBodyParams: any = undefined;

    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new Error(
        "Required parameter teamId was null or undefined when calling teamMembers."
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number"
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters["page_size"] = ObjectSerializer.serialize(
        pageSize,
        "number"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: AxiosRequestConfig = {
      method: "GET",
      params: localVarQueryParameters,
      headers: localVarHeaderParams,
      url: localVarPath,
      paramsSerializer: this._useQuerystring
        ? queryParamsSerializer
        : undefined,
      responseType: "json",
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.api_key.username) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.api_key.applyToRequest(localVarRequestOptions)
      );
    }
    if (this.authentications.oauth2.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.oauth2.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      return new Promise<returnTypeT<TeamMembersResponse>>(
        (resolve, reject) => {
          axios.request(localVarRequestOptions).then(
            (response) => {
              let body = response.data;

              if (
                response.status &&
                response.status >= 200 &&
                response.status <= 299
              ) {
                body = ObjectSerializer.deserialize(
                  body,
                  "TeamMembersResponse"
                );
                resolve({ response: response, body: body });
              } else {
                reject(new HttpError(response, body, response.status));
              }
            },
            (error: AxiosError) => {
              if (error.response == null) {
                reject(error);
                return;
              }

              const response = error.response;

              let body;

              if (response.status === 200) {
                body = ObjectSerializer.deserialize(
                  response.data,
                  "TeamMembersResponse"
                );

                reject(new HttpError(response, body, response.status));
                return;
              }

              let rangeCodeLeft = Number("4XX"[0] + "00");
              let rangeCodeRight = Number("4XX"[0] + "99");
              if (
                response.status >= rangeCodeLeft &&
                response.status <= rangeCodeRight
              ) {
                body = ObjectSerializer.deserialize(
                  response.data,
                  "ErrorResponse"
                );

                reject(new HttpError(response, body, response.status));
                return;
              }
            }
          );
        }
      );
    });
  }
  /**
   * Removes the provided user Account from your Team. If the Account had an outstanding invitation to your Team, the invitation will be expired. If you choose to transfer documents from the removed Account to an Account provided in the `new_owner_email_address` parameter (available only for Enterprise plans), the response status code will be 201, which indicates that your request has been queued but not fully executed.
   * @summary Remove User from Team
   * @param teamRemoveMemberRequest
   * @param options
   */
  public async teamRemoveMember(
    teamRemoveMemberRequest: TeamRemoveMemberRequest,
    options: optionsI = { headers: {} }
  ): Promise<returnTypeT<TeamGetResponse>> {
    const localVarPath = this.basePath + "/team/remove_member";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams["content-type"] = "application/json";
    } else {
      localVarHeaderParams["content-type"] = produces.join(",");
    }
    let localVarFormParams: any = {};
    let localVarBodyParams: any = undefined;

    // verify required parameter 'teamRemoveMemberRequest' is not null or undefined
    if (
      teamRemoveMemberRequest === null ||
      teamRemoveMemberRequest === undefined
    ) {
      throw new Error(
        "Required parameter teamRemoveMemberRequest was null or undefined when calling teamRemoveMember."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    const result = generateFormData(
      teamRemoveMemberRequest,
      TeamRemoveMemberRequest.attributeTypeMap,
      this._instantiateFiles,
      this._rootFilePath
    );
    localVarUseFormData = result.localVarUseFormData;

    let data = {};
    if (localVarUseFormData) {
      const formData = toFormData(result.data);
      data = formData;
      localVarHeaderParams = {
        ...localVarHeaderParams,
        ...formData.getHeaders(),
      };
    } else {
      data = ObjectSerializer.serialize(
        teamRemoveMemberRequest,
        "TeamRemoveMemberRequest"
      );
    }

    let localVarRequestOptions: AxiosRequestConfig = {
      method: "POST",
      params: localVarQueryParameters,
      headers: localVarHeaderParams,
      url: localVarPath,
      paramsSerializer: this._useQuerystring
        ? queryParamsSerializer
        : undefined,
      responseType: "json",
      data,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.api_key.username) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.api_key.applyToRequest(localVarRequestOptions)
      );
    }
    if (this.authentications.oauth2.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.oauth2.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      return new Promise<returnTypeT<TeamGetResponse>>((resolve, reject) => {
        axios.request(localVarRequestOptions).then(
          (response) => {
            let body = response.data;

            if (
              response.status &&
              response.status >= 200 &&
              response.status <= 299
            ) {
              body = ObjectSerializer.deserialize(body, "TeamGetResponse");
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.status));
            }
          },
          (error: AxiosError) => {
            if (error.response == null) {
              reject(error);
              return;
            }

            const response = error.response;

            let body;

            if (response.status === 200) {
              body = ObjectSerializer.deserialize(
                response.data,
                "TeamGetResponse"
              );

              reject(new HttpError(response, body, response.status));
              return;
            }

            let rangeCodeLeft = Number("4XX"[0] + "00");
            let rangeCodeRight = Number("4XX"[0] + "99");
            if (
              response.status >= rangeCodeLeft &&
              response.status <= rangeCodeRight
            ) {
              body = ObjectSerializer.deserialize(
                response.data,
                "ErrorResponse"
              );

              reject(new HttpError(response, body, response.status));
              return;
            }
          }
        );
      });
    });
  }
  /**
   * Provides a paginated list of sub teams that belong to a given team.
   * @summary List Sub Teams
   * @param teamId The id of the parent Team.
   * @param page Which page number of the SubTeam List to return. Defaults to &#x60;1&#x60;.
   * @param pageSize Number of objects to be returned per page. Must be between &#x60;1&#x60; and &#x60;100&#x60;. Default is &#x60;20&#x60;.
   * @param options
   */
  public async teamSubTeams(
    teamId: string,
    page?: number,
    pageSize?: number,
    options: optionsI = { headers: {} }
  ): Promise<returnTypeT<TeamSubTeamsResponse>> {
    const localVarPath =
      this.basePath +
      "/team/sub_teams/{team_id}".replace(
        "{" + "team_id" + "}",
        encodeURIComponent(String(teamId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams["content-type"] = "application/json";
    } else {
      localVarHeaderParams["content-type"] = produces.join(",");
    }
    let localVarFormParams: any = {};
    let localVarBodyParams: any = undefined;

    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new Error(
        "Required parameter teamId was null or undefined when calling teamSubTeams."
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number"
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters["page_size"] = ObjectSerializer.serialize(
        pageSize,
        "number"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: AxiosRequestConfig = {
      method: "GET",
      params: localVarQueryParameters,
      headers: localVarHeaderParams,
      url: localVarPath,
      paramsSerializer: this._useQuerystring
        ? queryParamsSerializer
        : undefined,
      responseType: "json",
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.api_key.username) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.api_key.applyToRequest(localVarRequestOptions)
      );
    }
    if (this.authentications.oauth2.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.oauth2.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      return new Promise<returnTypeT<TeamSubTeamsResponse>>(
        (resolve, reject) => {
          axios.request(localVarRequestOptions).then(
            (response) => {
              let body = response.data;

              if (
                response.status &&
                response.status >= 200 &&
                response.status <= 299
              ) {
                body = ObjectSerializer.deserialize(
                  body,
                  "TeamSubTeamsResponse"
                );
                resolve({ response: response, body: body });
              } else {
                reject(new HttpError(response, body, response.status));
              }
            },
            (error: AxiosError) => {
              if (error.response == null) {
                reject(error);
                return;
              }

              const response = error.response;

              let body;

              if (response.status === 200) {
                body = ObjectSerializer.deserialize(
                  response.data,
                  "TeamSubTeamsResponse"
                );

                reject(new HttpError(response, body, response.status));
                return;
              }

              let rangeCodeLeft = Number("4XX"[0] + "00");
              let rangeCodeRight = Number("4XX"[0] + "99");
              if (
                response.status >= rangeCodeLeft &&
                response.status <= rangeCodeRight
              ) {
                body = ObjectSerializer.deserialize(
                  response.data,
                  "ErrorResponse"
                );

                reject(new HttpError(response, body, response.status));
                return;
              }
            }
          );
        }
      );
    });
  }
  /**
   * Updates the name of your Team.
   * @summary Update Team
   * @param teamUpdateRequest
   * @param options
   */
  public async teamUpdate(
    teamUpdateRequest: TeamUpdateRequest,
    options: optionsI = { headers: {} }
  ): Promise<returnTypeT<TeamGetResponse>> {
    const localVarPath = this.basePath + "/team";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams["content-type"] = "application/json";
    } else {
      localVarHeaderParams["content-type"] = produces.join(",");
    }
    let localVarFormParams: any = {};
    let localVarBodyParams: any = undefined;

    // verify required parameter 'teamUpdateRequest' is not null or undefined
    if (teamUpdateRequest === null || teamUpdateRequest === undefined) {
      throw new Error(
        "Required parameter teamUpdateRequest was null or undefined when calling teamUpdate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    const result = generateFormData(
      teamUpdateRequest,
      TeamUpdateRequest.attributeTypeMap,
      this._instantiateFiles,
      this._rootFilePath
    );
    localVarUseFormData = result.localVarUseFormData;

    let data = {};
    if (localVarUseFormData) {
      const formData = toFormData(result.data);
      data = formData;
      localVarHeaderParams = {
        ...localVarHeaderParams,
        ...formData.getHeaders(),
      };
    } else {
      data = ObjectSerializer.serialize(teamUpdateRequest, "TeamUpdateRequest");
    }

    let localVarRequestOptions: AxiosRequestConfig = {
      method: "PUT",
      params: localVarQueryParameters,
      headers: localVarHeaderParams,
      url: localVarPath,
      paramsSerializer: this._useQuerystring
        ? queryParamsSerializer
        : undefined,
      responseType: "json",
      data,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.api_key.username) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.api_key.applyToRequest(localVarRequestOptions)
      );
    }
    if (this.authentications.oauth2.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.oauth2.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      return new Promise<returnTypeT<TeamGetResponse>>((resolve, reject) => {
        axios.request(localVarRequestOptions).then(
          (response) => {
            let body = response.data;

            if (
              response.status &&
              response.status >= 200 &&
              response.status <= 299
            ) {
              body = ObjectSerializer.deserialize(body, "TeamGetResponse");
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.status));
            }
          },
          (error: AxiosError) => {
            if (error.response == null) {
              reject(error);
              return;
            }

            const response = error.response;

            let body;

            if (response.status === 200) {
              body = ObjectSerializer.deserialize(
                response.data,
                "TeamGetResponse"
              );

              reject(new HttpError(response, body, response.status));
              return;
            }

            let rangeCodeLeft = Number("4XX"[0] + "00");
            let rangeCodeRight = Number("4XX"[0] + "99");
            if (
              response.status >= rangeCodeLeft &&
              response.status <= rangeCodeRight
            ) {
              body = ObjectSerializer.deserialize(
                response.data,
                "ErrorResponse"
              );

              reject(new HttpError(response, body, response.status));
              return;
            }
          }
        );
      });
    });
  }
}
